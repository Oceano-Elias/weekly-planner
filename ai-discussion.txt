# Drag and Drop Performance & UX Discussion

The current Pointer Events implementation is a solid foundation. To achieve "Linear-grade" polish, here are my specific recommendations for the next iteration:

## 1. Rendering: Snapshotting
Instead of `cloneNode(true)`, we should consider rendering the task to a canvas or a single static image on `pointerdown`.
- **Benefit**: Moving a single image layer is significantly cheaper for the GPU than tracking a complex DOM subtree with multiple nested nodes and text.

## 2. Hit Testing: Geometric Math
Replace `document.elementFromPoint` with a coordinate-based lookup.
- **Implementation**: Cache column `x` bounds and cell heights once per drag session. 
- **Benefit**: Number comparison (x > left && x < right) is 100x faster than the browser's hit-test engine and prevents layout thrashing entirely.

## 3. UX: "Magnetic" Spring Physics
Instead of toggling classes on the grid cells, use a single global "Drop Highlight" element.
- **Benefit**: We can animate this highlight using a spring effect (CSS transition or JS frame-tweening). It makes the task feel like it's being "sucked" into a valid slot, which feels more responsive and high-end.

## 4. Input: Micro-Drag Deadzone
Implement a ~5-pixel movement threshold before the drag state activates.
- **Benefit**: Prevents jittery mouse clicks from accidentally starting a drag when the user just wanted to click/edit.

## 5. Visuals: Velocity-Based Tilt
Add `rotate(2deg)` to the ghost element's `translate3d`.
- **Benefit**: We can increase the tilt based on `e.movementX`. It adds physical weight and "wind resistance" to the UI, making it feel less like a browser and more like a real object.

## 6. Logic: Pre-computed Availability Map
Pre-calculate all available time gaps for the entire week on `pointerdown`.
- **Benefit**: `isSlotAvailable` becomes a O(1) boolean lookup, removing all Store-related latency during high-speed movements.
